<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta name="theme-color" content="#1a1a2e" />
    <meta name="description" content="HexSnake - ÂÖ≠ËæπÂΩ¢Ë¥™ÂêÉËõáÊ∏∏ÊàèÔºåÂÖ∑ÊúâÂèåÈù¢ÁøªËΩ¨Êú∫Âà∂" />
    <title>HexSnake - ÂÖ≠ËæπÂΩ¢Ë¥™ÂêÉËõá</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: 'Arial', sans-serif;
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        color: #ffffff;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }

      .game-container {
        text-align: center;
        padding: 20px;
      }

      .game-title {
        font-size: 2rem;
        font-weight: bold;
        margin-bottom: 20px;
        color: #4ade80;
        text-shadow: 0 0 20px rgba(74, 222, 128, 0.3);
      }

      .game-board {
        position: relative;
        margin: 20px 0;
      }

      .game-svg {
        max-width: 100%;
        max-height: 80vh;
        border-radius: 10px;
        box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
      }

      .game-info {
        display: flex;
        justify-content: space-between;
        margin: 20px 0;
        font-size: 1.2rem;
        font-weight: bold;
      }

      .score {
        color: #f472b6;
      }

      .current-side {
        color: #60a5fa;
      }

      .controls {
        margin-top: 20px;
        font-size: 0.9rem;
        color: #a5b4fc;
      }

      .game-over {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(26, 26, 46, 0.95);
        padding: 30px;
        border-radius: 10px;
        text-align: center;
        box-shadow: 0 0 30px rgba(74, 222, 128, 0.3);
        border: 2px solid #4ade80;
      }

      .game-over h2 {
        font-size: 2rem;
        margin-bottom: 10px;
        color: #f87171;
      }

      .game-over-score {
        font-size: 1.5rem;
        margin-bottom: 20px;
        color: #f472b6;
      }

      .game-over button {
        background: #4ade80;
        color: #1a1a2e;
        border: none;
        padding: 10px 20px;
        font-size: 1rem;
        font-weight: bold;
        border-radius: 5px;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .game-over button:hover {
        background: #22c55e;
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(34, 197, 94, 0.3);
      }

      .eat-effect {
        position: absolute;
        font-size: 1.5rem;
        font-weight: bold;
        color: #f472b6;
        text-shadow: 0 0 10px rgba(244, 114, 182, 0.8);
        animation: pop 0.5s ease-out forwards;
        pointer-events: none;
      }

      @keyframes pop {
        0% {
          transform: scale(0) translateY(0);
          opacity: 1;
        }
        50% {
          transform: scale(1.5) translateY(-20px);
          opacity: 1;
        }
        100% {
          transform: scale(1) translateY(-40px);
          opacity: 0;
        }
      }

      @media (max-width: 768px) {
        .game-title {
          font-size: 1.5rem;
        }

        .game-info {
          font-size: 1rem;
          flex-direction: column;
          gap: 10px;
        }

        .controls {
          font-size: 0.8rem;
        }
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script>
      const { useState, useEffect, useRef } = React;

      // Ê∏∏ÊàèÈÖçÁΩÆ
      const HEX_SIZE = 10;
      const HEX_WIDTH = HEX_SIZE * 2;
      const HEX_HEIGHT = Math.sqrt(3) * HEX_SIZE;
      const GRID_RADIUS = 15;

      // Á±ªÂûãÂÆö‰πâ
      const Direction = {
        RIGHT: 0,
        DOWN_RIGHT: 1,
        DOWN_LEFT: 2,
        LEFT: 3,
        UP_LEFT: 4,
        UP_RIGHT: 5
      };

      const DIRECTION_VECTORS = {
        [Direction.RIGHT]: { q: 1, r: 0 },
        [Direction.DOWN_RIGHT]: { q: 0, r: 1 },
        [Direction.DOWN_LEFT]: { q: -1, r: 1 },
        [Direction.LEFT]: { q: -1, r: 0 },
        [Direction.UP_LEFT]: { q: 0, r: -1 },
        [Direction.UP_RIGHT]: { q: 1, r: -1 }
      };

      // ÁøªËΩ¨ËæπÂØπ
      const WRAP_EDGE_PAIRS = [
        {
          name: 'horizontal',
          checks: [(c) => c.q === -GRID_RADIUS, (c) => c.q === GRID_RADIUS]
        },
        {
          name: 'diagonal1',
          checks: [(c) => c.r === GRID_RADIUS, (c) => c.r === -GRID_RADIUS]
        },
        {
          name: 'diagonal2',
          checks: [(c) => -c.q - c.r === GRID_RADIUS, (c) => -c.q - c.r === -GRID_RADIUS]
        }
      ];

      const FIXED_WRAP_PAIR_INDEX = Math.floor(Math.random() * 3);

      // Â∑•ÂÖ∑ÂáΩÊï∞
      function isValidPosition(coord) {
        const s = -coord.q - coord.r;
        return Math.abs(coord.q) <= GRID_RADIUS && 
               Math.abs(coord.r) <= GRID_RADIUS && 
               Math.abs(s) <= GRID_RADIUS;
      }

      function getValidHexCells() {
        const cells = [];
        for (let q = -GRID_RADIUS; q <= GRID_RADIUS; q++) {
          const r1 = Math.max(-GRID_RADIUS, -q - GRID_RADIUS);
          const r2 = Math.min(GRID_RADIUS, -q + GRID_RADIUS);
          for (let r = r1; r <= r2; r++) {
            cells.push({ q, r });
          }
        }
        return cells;
      }

      function isSameCoord(a, b) {
        return a.q === b.q && a.r === b.r;
      }

      function isOnSnake(coord, side, snake) {
        return snake.some(segment => isSameCoord(segment, coord) && segment.side === side);
      }

      function isWrapExit(coord) {
        return WRAP_EDGE_PAIRS[FIXED_WRAP_PAIR_INDEX].checks.some(check => check(coord));
      }

      function isOnAnyEdge(coord) {
        return WRAP_EDGE_PAIRS.some(pair => pair.checks.some(check => check(coord)));
      }

      function getExitInfo(coord, direction) {
        const vector = DIRECTION_VECTORS[direction];
        const next = { q: coord.q + vector.q, r: coord.r + vector.r };

        if (!isValidPosition(next)) {
          if (isWrapExit(coord)) {
            const newCoord = {
              q: -coord.q,
              r: -coord.r
            };
            return { isWrap: true, newCoord };
          }
          return { isWrap: false };
        }
        return { isWrap: false };
      }

      function generateFood(snake, targetSide) {
        const validCells = getValidHexCells();
        const availablePositions = [];

        for (const cell of validCells) {
          const sidesToCheck = targetSide !== undefined ? [targetSide] : [0, 1];
          for (const side of sidesToCheck) {
            if (!isOnSnake(cell, side, snake)) {
              availablePositions.push({ ...cell, side });
            }
          }
        }

        if (availablePositions.length === 0) return { q: 0, r: 0, side: 0 };
        return availablePositions[Math.floor(Math.random() * availablePositions.length)];
      }

      function getNextPosition(head, direction) {
        const vector = DIRECTION_VECTORS[direction];
        return { q: head.q + vector.q, r: head.r + vector.r };
      }

      function hexToPixel(q, r) {
        const x = HEX_SIZE * (3/2 * q);
        const y = HEX_SIZE * (Math.sqrt(3)/2 * q + Math.sqrt(3) * r);
        return { x, y };
      }

      function createHexPath(centerX, centerY, size) {
        const points = [];
        for (let i = 0; i < 6; i++) {
          const angle = (Math.PI / 3) * i;
          const x = centerX + size * Math.cos(angle);
          const y = centerY + size * Math.sin(angle);
          points.push(`${x},${y}`);
        }
        return `M ${points.join(' L ')} Z`;
      }

      // ‰∏ªÊ∏∏ÊàèÁªÑ‰ª∂
      function App() {
        const [gameState, setGameState] = useState(() => {
          const initialSnake = [
            { q: 0, r: 0, side: 0 },
            { q: -1, r: 0, side: 0 },
            { q: -2, r: 0, side: 0 }
          ];
          return {
            snake: initialSnake,
            food: generateFood(initialSnake),
            direction: 0,
            score: 0,
            isPlaying: false,
            gameOver: false,
            currentSide: 0,
            eatEffect: null,
            wrapImmunity: 0
          };
        });

        const gameLoopRef = useRef(null);
        const effectTimeoutRef = useRef(null);
        const validCells = useRef(getValidHexCells());

        useEffect(() => {
          const handleKeyDown = (e) => {
            switch (e.key) {
              case 'ArrowLeft':
                setGameState(prev => ({
                  ...prev,
                  direction: (prev.direction + 5) % 6
                }));
                break;
              case 'ArrowRight':
                setGameState(prev => ({
                  ...prev,
                  direction: (prev.direction + 1) % 6
                }));
                break;
              case ' ':
                setGameState(prev => ({
                  ...prev,
                  isPlaying: !prev.isPlaying
                }));
                break;
              case 'r':
              case 'R':
                const initialSnake = [
                  { q: 0, r: 0, side: 0 },
                  { q: -1, r: 0, side: 0 },
                  { q: -2, r: 0, side: 0 }
                ];
                setGameState({
                  snake: initialSnake,
                  food: generateFood(initialSnake),
                  direction: 0,
                  score: 0,
                  isPlaying: false,
                  gameOver: false,
                  currentSide: 0,
                  eatEffect: null,
                  wrapImmunity: 0
                });
                break;
            }
          };

          window.addEventListener('keydown', handleKeyDown);
          return () => window.removeEventListener('keydown', handleKeyDown);
        }, []);

        useEffect(() => {
          if (gameState.isPlaying && !gameState.gameOver) {
            gameLoopRef.current = setInterval(() => {
              setGameState(prev => {
                const head = prev.snake[0];
                let newHead;
                let newSide = head.side;
                let flipped = false;

                const nextCoord = getNextPosition(head, prev.direction);
                const exitInfo = getExitInfo(head, prev.direction);

                if (exitInfo.isWrap && exitInfo.newCoord) {
                  newHead = { ...exitInfo.newCoord, side: 1 - head.side };
                  newSide = newHead.side;
                  flipped = true;
                } else if (!isValidPosition(nextCoord)) {
                  return { ...prev, gameOver: true, isPlaying: false };
                } else {
                  newHead = { ...nextCoord, side: head.side };
                }

                if (isOnSnake(newHead, newSide, prev.snake)) {
                  return { ...prev, gameOver: true, isPlaying: false };
                }

                const newSnake = [newHead, ...prev.snake];
                let newFood = prev.food;
                let newScore = prev.score;
                let newEatEffect = prev.eatEffect;
                let newCurrentSide = flipped ? newSide : prev.currentSide;
                let newWrapImmunity = prev.wrapImmunity;

                if (flipped) {
                  newWrapImmunity = 1;
                  const flippedFoodCoord = {
                    q: -prev.food.q,
                    r: -prev.food.r
                  };
                  if (isValidPosition(flippedFoodCoord)) {
                    newFood = {
                      q: flippedFoodCoord.q,
                      r: flippedFoodCoord.r,
                      side: newSide
                    };
                  } else {
                    newFood = generateFood(newSnake, newSide);
                  }
                } else if (newWrapImmunity > 0) {
                  newWrapImmunity--;
                }

                if (isSameCoord(newHead, prev.food) && newHead.side === prev.food.side) {
                  newScore += 10;
                  newFood = generateFood(newSnake);
                  const headPixel = hexToPixel(newHead.q, newHead.r);
                  newEatEffect = {
                    x: headPixel.x,
                    y: headPixel.y,
                    active: true,
                    timestamp: Date.now()
                  };

                  if (effectTimeoutRef.current) {
                    clearTimeout(effectTimeoutRef.current);
                  }

                  effectTimeoutRef.current = setTimeout(() => {
                    setGameState(s => ({ ...s, eatEffect: null }));
                  }, 500);
                } else {
                  newSnake.pop();
                }

                return {
                  ...prev,
                  snake: newSnake,
                  food: newFood,
                  score: newScore,
                  currentSide: newCurrentSide,
                  eatEffect: newEatEffect,
                  wrapImmunity: newWrapImmunity
                };
              });
            }, 120);
          } else if (gameLoopRef.current) {
            clearInterval(gameLoopRef.current);
            gameLoopRef.current = null;
          }

          return () => {
            if (gameLoopRef.current) {
              clearInterval(gameLoopRef.current);
            }
          };
        }, [gameState.isPlaying, gameState.gameOver]);

        const viewBoxWidth = (GRID_RADIUS * 3 + 2) * HEX_SIZE;
        const viewBoxHeight = (GRID_RADIUS * 2 + 2) * HEX_HEIGHT;

        return (
          <div className="game-container">
            <h1 className="game-title">üêç HexSnake - ÂÖ≠ËæπÂΩ¢Ë¥™ÂêÉËõá</h1>
            
            <div className="game-info">
              <div className="score">ÂàÜÊï∞: {gameState.score}</div>
              <div className="current-side">ÂΩìÂâçÈù¢: {gameState.currentSide === 0 ? 'A' : 'B'}</div>
            </div>

            <div className="game-board">
              <svg 
                viewBox={`${-viewBoxWidth/2} ${-viewBoxHeight/2} ${viewBoxWidth} ${viewBoxHeight}`}
                className="game-svg"
              >
                {validCells.current.map((cell, index) => {
                  const { x, y } = hexToPixel(cell.q, cell.r);
                  const snakeOnCell = gameState.snake.filter(s => s.side === gameState.currentSide);
                  const isSnakeHead = isSameCoord(cell, snakeOnCell[0] || { q: -999, r: -999 });
                  const isSnakeBody = snakeOnCell.slice(1).some(s => isSameCoord(s, cell));
                  const isFood = isSameCoord(cell, gameState.food) && gameState.food.side === gameState.currentSide;
                  const isOtherSideFood = isSameCoord(cell, gameState.food) && gameState.food.side !== gameState.currentSide;
                  const onActiveWrapEdge = isWrapExit(cell);
                  const onOtherEdge = isOnAnyEdge(cell) && !onActiveWrapEdge;

                  let fillColor = '#1e1e32';
                  let strokeColor = '#2d2d4a';

                  if (isSnakeHead) {
                    fillColor = '#4ade80';
                    strokeColor = '#22c55e';
                  } else if (isSnakeBody) {
                    fillColor = '#22c55e';
                    strokeColor = '#16a34a';
                  } else if (isFood) {
                    fillColor = '#f472b6';
                    strokeColor = '#ec4899';
                  } else if (isOtherSideFood) {
                    fillColor = '#4c1d95';
                    strokeColor = '#7c3aed';
                  } else if (onActiveWrapEdge) {
                    fillColor = '#1e3a5f';
                    strokeColor = '#3b82f6';
                  } else if (onOtherEdge) {
                    fillColor = '#1e1e32';
                    strokeColor = '#ef4444';
                  }

                  return (
                    <g key={index}>
                      <path
                        d={createHexPath(x, y, HEX_SIZE - 1)}
                        fill={fillColor}
                        stroke={strokeColor}
                        strokeWidth={onActiveWrapEdge ? "3" : "1.5"}
                      />
                      {isSnakeHead && (
                        <>
                          <circle 
                            cx={x + HEX_SIZE * 0.3} 
                            cy={y - HEX_SIZE * 0.3} 
                            r={HEX_SIZE * 0.15} 
                            fill="#ffffff"
                          />
                          <circle 
                            cx={x - HEX_SIZE * 0.3} 
                            cy={y - HEX_SIZE * 0.3} 
                            r={HEX_SIZE * 0.15} 
                            fill="#ffffff"
                          />
                        </>
                      )}
                    </g>
                  );
                })}
              </svg>
              
              {gameState.gameOver && (
                <div className="game-over">
                  <h2>Ê∏∏ÊàèÁªìÊùü!</h2>
                  <div className="game-over-score">ÊúÄÁªàÂàÜÊï∞: {gameState.score}</div>
                  <button onClick={() => {
                    const initialSnake = [
                      { q: 0, r: 0, side: 0 },
                      { q: -1, r: 0, side: 0 },
                      { q: -2, r: 0, side: 0 }
                    ];
                    setGameState({
                      snake: initialSnake,
                      food: generateFood(initialSnake),
                      direction: 0,
                      score: 0,
                      isPlaying: false,
                      gameOver: false,
                      currentSide: 0,
                      eatEffect: null,
                      wrapImmunity: 0
                    });
                  }}>
                    ÈáçÊñ∞ÂºÄÂßã
                  </button>
                </div>
              )}

              {!gameState.gameOver && !gameState.isPlaying && (
                <div className="game-over" style={{ background: 'rgba(26, 26, 46, 0.8)' }}>
                  <h2>ÊåâÁ©∫Ê†ºÈîÆÂºÄÂßãÊ∏∏Êàè</h2>
                  <div className="game-over-score">ÂàÜÊï∞: {gameState.score}</div>
                </div>
              )}

              {gameState.eatEffect && (
                <div 
                  className="eat-effect"
                  style={{
                    left: `${viewBoxWidth/2 + gameState.eatEffect.x}px`,
                    top: `${viewBoxHeight/2 + gameState.eatEffect.y}px`
                  }}
                >
                  +10
                </div>
              )}
            </div>

            <div className="controls">
              ‚Üê Â∑¶ËΩ¨ | ‚Üí Âè≥ËΩ¨ | Á©∫Ê†º: ÊöÇÂÅú/ÂºÄÂßã | R: ÈáçÊñ∞ÂºÄÂßã
            </div>
          </div>
        );
      }

      ReactDOM.render(<App />, document.getElementById('root'));
    </script>
  </body>
</html>