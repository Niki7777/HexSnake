<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta name="theme-color" content="#1a1a2e" />
    <meta name="description" content="HexSnake - ÂÖ≠ËæπÂΩ¢Ë¥™ÂêÉËõáÊ∏∏Êàè" />
    <title>HexSnake - ÂÖ≠ËæπÂΩ¢Ë¥™ÂêÉËõá</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: 'Arial', sans-serif;
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        color: #ffffff;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }

      .game-container {
        text-align: center;
        padding: 20px;
        max-width: 800px;
        width: 100%;
      }

      .game-title {
        font-size: 2rem;
        font-weight: bold;
        margin-bottom: 20px;
        color: #4ade80;
        text-shadow: 0 0 20px rgba(74, 222, 128, 0.3);
      }

      .game-info {
        display: flex;
        justify-content: space-between;
        margin: 20px 0;
        font-size: 1.2rem;
        font-weight: bold;
      }

      .score {
        color: #f472b6;
      }

      .current-side {
        color: #60a5fa;
      }

      .controls {
        margin-top: 20px;
        font-size: 0.9rem;
        color: #a5b4fc;
      }

      .game-board {
        position: relative;
        margin: 20px 0;
        width: 100%;
        height: 60vh;
        min-height: 400px;
      }

      .game-svg {
        width: 100%;
        height: 100%;
        border-radius: 10px;
        box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
      }

      .game-over {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(26, 26, 46, 0.95);
        padding: 30px;
        border-radius: 10px;
        text-align: center;
        box-shadow: 0 0 30px rgba(74, 222, 128, 0.3);
        border: 2px solid #4ade80;
        z-index: 10;
      }

      .game-over h2 {
        font-size: 2rem;
        margin-bottom: 10px;
        color: #f87171;
      }

      .game-over-score {
        font-size: 1.5rem;
        margin-bottom: 20px;
        color: #f472b6;
      }

      .game-over button {
        background: #4ade80;
        color: #1a1a2e;
        border: none;
        padding: 10px 20px;
        font-size: 1rem;
        font-weight: bold;
        border-radius: 5px;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .game-over button:hover {
        background: #22c55e;
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(34, 197, 94, 0.3);
      }

      .eat-effect {
        position: absolute;
        font-size: 1.5rem;
        font-weight: bold;
        color: #f472b6;
        text-shadow: 0 0 10px rgba(244, 114, 182, 0.8);
        animation: pop 0.5s ease-out forwards;
        pointer-events: none;
        z-index: 5;
      }

      @keyframes pop {
        0% {
          transform: scale(0) translateY(0);
          opacity: 1;
        }
        50% {
          transform: scale(1.5) translateY(-20px);
          opacity: 1;
        }
        100% {
          transform: scale(1) translateY(-40px);
          opacity: 0;
        }
      }

      @media (max-width: 768px) {
        .game-title {
          font-size: 1.5rem;
        }

        .game-info {
          font-size: 1rem;
          flex-direction: column;
          gap: 10px;
        }

        .controls {
          font-size: 0.8rem;
        }

        .game-board {
          height: 50vh;
          min-height: 300px;
        }
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script src="https://unpkg.com/react@17/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"></script>
    <script>
      const { useState, useEffect, useRef } = React;

      // Ê∏∏ÊàèÈÖçÁΩÆ
      const HEX_SIZE = 10;
      const GRID_RADIUS = 15;

      // ÊñπÂêëÂÆö‰πâ
      const Direction = {
        RIGHT: 0,
        DOWN_RIGHT: 1,
        DOWN_LEFT: 2,
        LEFT: 3,
        UP_LEFT: 4,
        UP_RIGHT: 5
      };

      // ÊñπÂêëÂêëÈáè
      const DIRECTION_VECTORS = [
        { q: 1, r: 0 },    // RIGHT
        { q: 0, r: 1 },    // DOWN_RIGHT
        { q: -1, r: 1 },   // DOWN_LEFT
        { q: -1, r: 0 },   // LEFT
        { q: 0, r: -1 },   // UP_LEFT
        { q: 1, r: -1 }    // UP_RIGHT
      ];

      // ÁøªËΩ¨ËæπÂØπ
      const WRAP_EDGE_PAIRS = [
        {
          name: 'horizontal',
          checks: [(c) => c.q === -GRID_RADIUS, (c) => c.q === GRID_RADIUS]
        },
        {
          name: 'diagonal1',
          checks: [(c) => c.r === GRID_RADIUS, (c) => c.r === -GRID_RADIUS]
        },
        {
          name: 'diagonal2',
          checks: [(c) => -c.q - c.r === GRID_RADIUS, (c) => -c.q - c.r === -GRID_RADIUS]
        }
      ];

      const FIXED_WRAP_PAIR_INDEX = Math.floor(Math.random() * 3);

      // Â∑•ÂÖ∑ÂáΩÊï∞
      function isValidPosition(coord) {
        const s = -coord.q - coord.r;
        return Math.abs(coord.q) <= GRID_RADIUS && 
               Math.abs(coord.r) <= GRID_RADIUS && 
               Math.abs(s) <= GRID_RADIUS;
      }

      function getValidHexCells() {
        const cells = [];
        for (let q = -GRID_RADIUS; q <= GRID_RADIUS; q++) {
          const r1 = Math.max(-GRID_RADIUS, -q - GRID_RADIUS);
          const r2 = Math.min(GRID_RADIUS, -q + GRID_RADIUS);
          for (let r = r1; r <= r2; r++) {
            cells.push({ q, r });
          }
        }
        return cells;
      }

      function isSameCoord(a, b) {
        return a.q === b.q && a.r === b.r;
      }

      function isOnSnake(coord, side, snake) {
        return snake.some(segment => isSameCoord(segment, coord) && segment.side === side);
      }

      function isWrapExit(coord) {
        return WRAP_EDGE_PAIRS[FIXED_WRAP_PAIR_INDEX].checks.some(check => check(coord));
      }

      function isOnAnyEdge(coord) {
        return WRAP_EDGE_PAIRS.some(pair => pair.checks.some(check => check(coord)));
      }

      function getExitInfo(coord, direction) {
        const vector = DIRECTION_VECTORS[direction];
        const next = { q: coord.q + vector.q, r: coord.r + vector.r };

        if (!isValidPosition(next)) {
          if (isWrapExit(coord)) {
            const newCoord = {
              q: -coord.q,
              r: -coord.r
            };
            return { isWrap: true, newCoord };
          }
          return { isWrap: false };
        }
        return { isWrap: false };
      }

      function generateFood(snake, targetSide) {
        const validCells = getValidHexCells();
        const availablePositions = [];

        for (const cell of validCells) {
          const sidesToCheck = targetSide !== undefined ? [targetSide] : [0, 1];
          for (const side of sidesToCheck) {
            if (!isOnSnake(cell, side, snake)) {
              availablePositions.push({ ...cell, side });
            }
          }
        }

        if (availablePositions.length === 0) return { q: 0, r: 0, side: 0 };
        return availablePositions[Math.floor(Math.random() * availablePositions.length)];
      }

      function getNextPosition(head, direction) {
        const vector = DIRECTION_VECTORS[direction];
        return { q: head.q + vector.q, r: head.r + vector.r };
      }

      function hexToPixel(q, r) {
        const x = HEX_SIZE * (3/2 * q);
        const y = HEX_SIZE * (Math.sqrt(3)/2 * q + Math.sqrt(3) * r);
        return { x, y };
      }

      function createHexPath(centerX, centerY, size) {
        const points = [];
        for (let i = 0; i < 6; i++) {
          const angle = (Math.PI / 3) * i;
          const x = centerX + size * Math.cos(angle);
          const y = centerY + size * Math.sin(angle);
          points.push(`${x},${y}`);
        }
        return `M ${points.join(' L ')} Z`;
      }

      // ‰∏ªÊ∏∏ÊàèÁªÑ‰ª∂
      function App() {
        // ÂàùÂßãÁä∂ÊÄÅ
        const [gameState, setGameState] = useState({
          snake: [
            { q: 0, r: 0, side: 0 },
            { q: -1, r: 0, side: 0 },
            { q: -2, r: 0, side: 0 }
          ],
          food: generateFood([
            { q: 0, r: 0, side: 0 },
            { q: -1, r: 0, side: 0 },
            { q: -2, r: 0, side: 0 }
          ]),
          direction: 0,
          score: 0,
          isPlaying: false,
          gameOver: false,
          currentSide: 0,
          eatEffect: null,
          wrapImmunity: 0
        });

        const gameLoopRef = useRef(null);
        const effectTimeoutRef = useRef(null);
        const validCells = useRef(getValidHexCells());

        // ÈîÆÁõòÊéßÂà∂
        useEffect(() => {
          const handleKeyDown = (e) => {
            switch (e.key) {
              case 'ArrowLeft':
                setGameState(prev => ({
                  ...prev,
                  direction: (prev.direction + 5) % 6
                }));
                break;
              case 'ArrowRight':
                setGameState(prev => ({
                  ...prev,
                  direction: (prev.direction + 1) % 6
                }));
                break;
              case ' ':
                setGameState(prev => ({
                  ...prev,
                  isPlaying: !prev.isPlaying
                }));
                break;
              case 'r':
              case 'R':
                const initialSnake = [
                  { q: 0, r: 0, side: 0 },
                  { q: -1, r: 0, side: 0 },
                  { q: -2, r: 0, side: 0 }
                ];
                setGameState({
                  snake: initialSnake,
                  food: generateFood(initialSnake),
                  direction: 0,
                  score: 0,
                  isPlaying: false,
                  gameOver: false,
                  currentSide: 0,
                  eatEffect: null,
                  wrapImmunity: 0
                });
                break;
            }
          };

          window.addEventListener('keydown', handleKeyDown);
          return () => window.removeEventListener('keydown', handleKeyDown);
        }, []);

        // Ê∏∏ÊàèÂæ™ÁéØ
        useEffect(() => {
          if (gameState.isPlaying && !gameState.gameOver) {
            gameLoopRef.current = setInterval(() => {
              setGameState(prev => {
                const head = prev.snake[0];
                let newHead;
                let newSide = head.side;
                let flipped = false;

                const nextCoord = getNextPosition(head, prev.direction);
                const exitInfo = getExitInfo(head, prev.direction);

                if (exitInfo.isWrap && exitInfo.newCoord) {
                  newHead = { ...exitInfo.newCoord, side: 1 - head.side };
                  newSide = newHead.side;
                  flipped = true;
                } else if (!isValidPosition(nextCoord)) {
                  return { ...prev, gameOver: true, isPlaying: false };
                } else {
                  newHead = { ...nextCoord, side: head.side };
                }

                if (isOnSnake(newHead, newSide, prev.snake)) {
                  return { ...prev, gameOver: true, isPlaying: false };
                }

                const newSnake = [newHead, ...prev.snake];
                let newFood = prev.food;
                let newScore = prev.score;
                let newEatEffect = prev.eatEffect;
                let newCurrentSide = flipped ? newSide : prev.currentSide;
                let newWrapImmunity = prev.wrapImmunity;

                if (flipped) {
                  newWrapImmunity = 1;
                  const flippedFoodCoord = {
                    q: -prev.food.q,
                    r: -prev.food.r
                  };
                  if (isValidPosition(flippedFoodCoord)) {
                    newFood = { ...flippedFoodCoord, side: newSide };
                  } else {
                    newFood = generateFood(newSnake, newSide);
                  }
                } else if (newWrapImmunity > 0) {
                  newWrapImmunity--;
                }

                if (isSameCoord(newHead, prev.food) && newHead.side === prev.food.side) {
                  newScore += 10;
                  newFood = generateFood(newSnake);
                  const headPixel = hexToPixel(newHead.q, newHead.r);
                  newEatEffect = {
                    x: headPixel.x,
                    y: headPixel.y,
                    timestamp: Date.now()
                  };

                  if (effectTimeoutRef.current) {
                    clearTimeout(effectTimeoutRef.current);
                  }

                  effectTimeoutRef.current = setTimeout(() => {
                    setGameState(s => ({ ...s, eatEffect: null }));
                  }, 500);
                } else {
                  newSnake.pop();
                }

                return {
                  ...prev,
                  snake: newSnake,
                  food: newFood,
                  score: newScore,
                  currentSide: newCurrentSide,
                  eatEffect: newEatEffect,
                  wrapImmunity: newWrapImmunity
                };
              });
            }, 120);
          } else if (gameLoopRef.current) {
            clearInterval(gameLoopRef.current);
            gameLoopRef.current = null;
          }

          return () => {
            if (gameLoopRef.current) {
              clearInterval(gameLoopRef.current);
            }
          };
        }, [gameState.isPlaying, gameState.gameOver]);

        // ËÆ°ÁÆóËßÜÂõæÂ§ßÂ∞è
        const viewBoxWidth = (GRID_RADIUS * 3 + 2) * HEX_SIZE;
        const viewBoxHeight = (GRID_RADIUS * 2 + 2) * HEX_SIZE * Math.sqrt(3);

        // Ê∏≤ÊüìÂáΩÊï∞
        const renderHexGrid = () => {
          return validCells.current.map((cell, index) => {
            const { x, y } = hexToPixel(cell.q, cell.r);
            const snakeOnCell = gameState.snake.filter(s => s.side === gameState.currentSide);
            const isSnakeHead = isSameCoord(cell, snakeOnCell[0] || { q: -999, r: -999 });
            const isSnakeBody = snakeOnCell.slice(1).some(s => isSameCoord(s, cell));
            const isFood = isSameCoord(cell, gameState.food) && gameState.food.side === gameState.currentSide;
            const isOtherSideFood = isSameCoord(cell, gameState.food) && gameState.food.side !== gameState.currentSide;
            const onActiveWrapEdge = isWrapExit(cell);
            const onOtherEdge = isOnAnyEdge(cell) && !onActiveWrapEdge;

            let fillColor = '#1e1e32';
            let strokeColor = '#2d2d4a';

            if (isSnakeHead) {
              fillColor = '#4ade80';
              strokeColor = '#22c55e';
            } else if (isSnakeBody) {
              fillColor = '#22c55e';
              strokeColor = '#16a34a';
            } else if (isFood) {
              fillColor = '#f472b6';
              strokeColor = '#ec4899';
            } else if (isOtherSideFood) {
              fillColor = '#4c1d95';
              strokeColor = '#7c3aed';
            } else if (onActiveWrapEdge) {
              fillColor = '#1e3a5f';
              strokeColor = '#3b82f6';
            } else if (onOtherEdge) {
              fillColor = '#1e1e32';
              strokeColor = '#ef4444';
            }

            const elements = [
              React.createElement('path', {
                key: `path-${index}`,
                d: createHexPath(x, y, HEX_SIZE - 1),
                fill: fillColor,
                stroke: strokeColor,
                strokeWidth: onActiveWrapEdge ? "3" : "1.5"
              })
            ];

            if (isSnakeHead) {
              elements.push(
                React.createElement('circle', {
                  key: `eye1-${index}`,
                  cx: x + HEX_SIZE * 0.3,
                  cy: y - HEX_SIZE * 0.3,
                  r: HEX_SIZE * 0.15,
                  fill: "#ffffff"
                }),
                React.createElement('circle', {
                  key: `eye2-${index}`,
                  cx: x - HEX_SIZE * 0.3,
                  cy: y - HEX_SIZE * 0.3,
                  r: HEX_SIZE * 0.15,
                  fill: "#ffffff"
                })
              );
            }

            return React.createElement('g', { key: index }, elements);
          });
        };

        return React.createElement('div', { className: 'game-container' },
          React.createElement('h1', { className: 'game-title' }, 'üêç HexSnake - ÂÖ≠ËæπÂΩ¢Ë¥™ÂêÉËõá'),
          React.createElement('div', { className: 'game-info' },
            React.createElement('div', { className: 'score' }, 'ÂàÜÊï∞: ', gameState.score),
            React.createElement('div', { className: 'current-side' }, 'ÂΩìÂâçÈù¢: ', gameState.currentSide === 0 ? 'A' : 'B')
          ),
          React.createElement('div', { className: 'game-board' },
            React.createElement('svg', {
              viewBox: `${-viewBoxWidth/2} ${-viewBoxHeight/2} ${viewBoxWidth} ${viewBoxHeight}`,
              className: 'game-svg'
            }, renderHexGrid()),
            gameState.gameOver && React.createElement('div', { className: 'game-over' },
              React.createElement('h2', null, 'Ê∏∏ÊàèÁªìÊùü!'),
              React.createElement('div', { className: 'game-over-score' }, 'ÊúÄÁªàÂàÜÊï∞: ', gameState.score),
              React.createElement('button', {
                onClick: () => {
                  const initialSnake = [
                    { q: 0, r: 0, side: 0 },
                    { q: -1, r: 0, side: 0 },
                    { q: -2, r: 0, side: 0 }
                  ];
                  setGameState({
                    snake: initialSnake,
                    food: generateFood(initialSnake),
                    direction: 0,
                    score: 0,
                    isPlaying: false,
                    gameOver: false,
                    currentSide: 0,
                    eatEffect: null,
                    wrapImmunity: 0
                  });
                }
              }, 'ÈáçÊñ∞ÂºÄÂßã')
            ),
            !gameState.gameOver && !gameState.isPlaying && React.createElement('div', {
              className: 'game-over',
              style: { background: 'rgba(26, 26, 46, 0.8)' }
            },
              React.createElement('h2', null, 'ÊåâÁ©∫Ê†ºÈîÆÂºÄÂßãÊ∏∏Êàè'),
              React.createElement('div', { className: 'game-over-score' }, 'ÂàÜÊï∞: ', gameState.score)
            ),
            gameState.eatEffect && React.createElement('div', {
              className: 'eat-effect',
              style: {
                left: `${viewBoxWidth/2 + gameState.eatEffect.x}px`,
                top: `${viewBoxHeight/2 + gameState.eatEffect.y}px`
              }
            }, '+10')
          ),
          React.createElement('div', { className: 'controls' },
            '‚Üê Â∑¶ËΩ¨ | ‚Üí Âè≥ËΩ¨ | Á©∫Ê†º: ÊöÇÂÅú/ÂºÄÂßã | R: ÈáçÊñ∞ÂºÄÂßã'
          )
        );
      }

      // Ê∏≤ÊüìÂ∫îÁî®
      ReactDOM.render(
        React.createElement(App),
        document.getElementById('root')
      );
    </script>
  </body>
</html>